之前列举的措施中，如果防止黑产和网页卡顿等现象出现，其实用户也能一定程度上理解，毕竟秒杀都很可能会卡顿和抢不到，最多大家没参与到活动，口吐芬芳一波。

但是，如果要是超卖了，本该拿到商品的用户可就不乐意了，轻则亏本发货，重则起诉赔偿，哪一样都吃不了兜着走。

以下开始从零开始搭建秒杀系统 demo。

## 数据库建表（简版）

### 库存表 stock

```mysql
DROP TABLE IF EXISTS `stock`;
CREATE TABLE `stock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL DEFAULT '' COMMENT '名称',
  `count` int(11) NOT NULL COMMENT '库存',
  `sale` int(11) NOT NULL COMMENT '已售',
  `version` int(11) NOT NULL COMMENT '乐观锁，版本号',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 订单表 stock_order

```mysql
DROP TABLE IF EXISTS `stock_order`;
CREATE TABLE `stock_order` (
                               `id`          int(11) unsigned NOT NULL AUTO_INCREMENT,
                               `sid`         int(11)          NOT NULL COMMENT '库存ID',
                               `name`        varchar(30)      NOT NULL DEFAULT '' COMMENT '商品名称',
                               `create_time` timestamp        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
                               PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8;
```

## 通过 HTTP 接口发起购买请求

只是个 demo，所以采用 Spring MVC + MyBatis 结构。

### 先用常规方案做一个购买请求接口

#### Controller 层 V0

提供一个接口，入参为商品 ID

```java
@RequestMapping("/createWrongOrder/{sid}")
@ResponseBody
public String createWrongOrder(@PathVariable int sid){
        log.info("购买物品编号sid=[{}]",sid);
        int id=0;
        try{
        id=orderService.createWrongOrder(sid);
        log.info("创建订单id: [{}]",id);
        }catch(Exception e){
        log.error("Exception",e);
        }
        return String.valueOf(id);
        }
```

#### Service 层 V0

```java
@Override
public int createWrongOrder(int sid)throws Exception{
        //校验库存
        Stock stock=checkStock(sid);
        //扣库存
        saleStock(stock);
        //创建订单
        int id=createWrongOrder(stock);
        return id;
        }

private Stock checkStock(int sid){
        Stock stock=stockService.getStockById(sid);
        if(stock.getSale().equals(stock.getCount())){
        throw new RuntimeException("库存不足");
        }
        return stock;
        }

private int saleStock(Stock stock){
        stock.setSale(stock.getSale()+1);
        return stockService.updateStockById(stock);
        }

private int createWrongOrder(Stock stock){
        StockOrder order=new StockOrder();
        order.setSid(stock.getId());
        order.setName(stock.getName());
        int id=orderMapper.insertSelective(order);
        return id;
        }
```

### 测试：发起并发购买请求，复现超卖问题

推荐使用【 [JMeter](https://jmeter.apache.org/) 】来模拟大量用户同时请求购买接口的场景。

为啥不使用 Postman？因为暂时不支持并发请求，只能顺序请求。

如何通过 JMeter 进行压测，可参考这篇 【[JMeter 压测教程](https://www.cnblogs.com/stulzq/p/8971531.html)】。

同时开启 1000 线程，抢数据库插入的 **100 台** iPhone，结果卖了 **16 台**，但是创建了 **1000 个**订单。

哭唧唧……是该表扬 Spring 强大的并发处理能力，还是该口吐芬芳 MySQL 这么成熟的数据库却不会给自己锁库存……

### 避免超卖问题：更新商品库存的版本号

为解决上述超卖问题，有几种方案：

- 悲观锁：在 Service 层给表更新添加事务，这样每个线程更新请求的时候先锁表的这一行，更新完库存之后释放锁。

#### 悲观锁方案 Controller 层 V1

#### 悲观锁方案 Service 层 V1

缺点：性能问题，1000 个线程存在阻塞。需要乐观锁。

- 乐观锁：一般有两种方案，CAS 和 version。最简单的办法就是，给每个商品库存一个版本号 version 字段。

修改之前的代码，createWrongOrder 修改为 createOptimisticOrder ~

#### 乐观锁方案 Controller 层 V2

```java
/**
 * 乐观锁更新库存
 * @param sid
 * @return
 */
@RequestMapping("/createOptimisticOrder/{sid}")
@ResponseBody
public String createOptimisticOrder(@PathVariable int sid) {
    int id;
    try {
        id = orderService.createOptimisticOrder(sid);
        log.info("购买成功，剩余库存为: [{}]", id);
    } catch (Exception e) {
        log.error("购买失败：[{}]", e.getMessage());
        return "购买失败，库存不足";
    }
    return String.format("购买成功，剩余库存为：%d", id);
}
```

#### 乐观锁方案 Service 层 V2

```java
@Override
public int createOptimisticOrder(int sid)throws Exception{
        //校验库存
        Stock stock=checkStock(sid);
        //乐观锁更新库存
        saleStockOptimistic(stock);
        //创建订单
        int id=createOrder(stock);
        return stock.getCount()-(stock.getSale()+1);
        }

private void saleStockOptimistic(Stock stock){
        log.info("查询数据库，尝试更新库存");
        int count=stockService.updateStockByOptimistic(stock);
        if(count==0){
        throw new RuntimeException("并发更新库存失败，version不匹配");
        }
        }
```

#### 乐观锁方案 Mapper

```xml
<update id="updateByOptimistic" parameterType="cn.monitor4all.miaoshadao.dao.Stock">
    UPDATE stock
    <set>
      sale = sale + 1,
      version = version + 1,
    </set>
    WHERE id = #{id, jdbcType=INTEGER}
    AND version = #{version, jdbcType=INTEGER}
</update>
```

在实际减库存的 SQL 操作中，首先判断 version 是否是我们查询库存时候的 version，如果是，扣减库存，秒杀成功；如果 version 变了，则不更新数据库，秒杀失败。

### 乐观锁方案测试：重新发起并发购买请求，验证正确秒杀

库存恢复 **100 台**，清空订单表，通过 JMeter 重新发起 **1000次**并发请求。

结果：卖出去 **39 台**，库存 version 更新为 39，创建了 **39 个订单**。没有超卖。

说明：由于并发访问的原因，很多线程更新库存失败了，所以在这种设计下，1000 人同时发起购买，只有 39 个人能买到。

其实这完全 OK，一方面用户其实无感知，另一方面还减少了秒杀造成的低收益甚至是亏本（本身秒杀就是为了提升人气和引流的），最关键的是，防止了超卖。

当然，如果用户更多的话，最终大概率是可以全部卖完的。

### 悲观锁和乐观锁两种方案的分析与比较

在海量请求的场景下，使用乐观锁，会导致大量请求返回抢购失败，用户体验可能较差。

 